# Event handling

- The reactive is based on *flags*
    - reactive programming
    - Use decorators (`when`, `when_not`, `when_all`) to register a handler which will trigger when the desired flags are active.
- The operator is based on *observer pattern*
    - observer pattern
    - The Juju controller emits events that Charmed Operators observe and respond to at key points during an applicationâ€™s lifecycle

## Reactive

**charm-infra-node** `./src/reactive/infra_node.py`

```python
from charms.reactive import hook, when, set_state, remove_state
from charmhelpers import fetch
from charmhelpers.core import hookenv
from charmhelpers.core.host import lsb_release, CompareHostReleases
from charmhelpers.contrib.charmsupport import nrpe
from lib_infra_node import InfranodeHelper


helper = InfranodeHelper()


@when('nrpe.render', 'nrpe-external-master.available')
def update_nrpe_confikkg():
    # python-dbus is used by check_upstart_job, libnagios-plugin-perl is used by the pacemaker checks.
    # The package was renamed in Bionic.
    _release = lsb_release()['DISTRIB_CODENAME'].lower()
    if CompareHostReleases(_release) <= 'xenial':
        fetch.apt_install(['python-dbus', 'libnagios-plugin-perl'], fatal=True)
    else:
        fetch.apt_install(['python-dbus', 'libmonitoring-plugin-perl'])
    hostname = nrpe.get_nagios_hostname()
    current_unit = nrpe.get_nagios_unit_name()
    nrpe_setup = nrpe.NRPE(hostname=hostname)
    helper.create_nrpe_checks(nrpe_setup, hostname, current_unit)
    remove_state('nrpe.render')


# use @hook here because @when('config.changed') misses changes to templates or files on charm upgrade
@hook('config-changed')
def do_config():
    set_state('files.render')
    set_state('nrpe.render')


@when('files.render')
def deploy_files():
    helper.deploy_scripts()
    helper.deploy_sudoers()
    remove_state('files.render')
    hookenv.status_set('active', 'ready')
```

> For someone who is interested in how `when` decorator works can trace the source code of charms.reactive.
> - `Handler`
>     - Class representing a reactive flag handler
> - `dispatch`
>     - Dispatch registered handlers.

## Operator

> https://juju.is/docs/sdk/constructs#heading--event-handling

**charm-ubuntu** `/src/charm.py`

```python
#!/usr/bin/env python3

import logging
from pathlib import Path
from subprocess import check_call, check_output

from ops.charm import CharmBase
from ops.main import main
from ops.model import ActiveStatus


log = logging.getLogger(__name__)


class UbuntuCharm(CharmBase):
    def __init__(self, *args):
        """Initialize charm.

        Setup hook event observers and any other basic initialization.
        """
        super().__init__(*args)

        for event in (
            self.on.install,
            self.on.leader_elected,
            self.on.upgrade_charm,
            self.on.post_series_upgrade,
        ):
            self.framework.observe(event, self._set_version)
        self.framework.observe(self.on.config_changed, self._update_hostname)

    def _set_version(self, _):
        """Set application version.

        Invoked for relevant hook events and, on the leader unit, determine and
        set the application-level workload version to the Ubuntu version upon
        which the charm is running.
        """
        self.unit.status = ActiveStatus()
        if not self.unit.is_leader():
            return
        try:
            output = check_output(["lsb_release", "-r", "-s"])
            version = output.decode("utf8").strip()
            self.unit.set_workload_version(version)
        except Exception:
            log.exception("Error getting release")

    def _update_hostname(self, event):
        """Update the machine hostname based on the config option."""
        hostname = self.config["hostname"]
        if not hostname:
            return

        Path("/etc/hostname").write_text(hostname)
        check_call(["hostname", hostname])


if __name__ == "__main__":
    main(UbuntuCharm)
```

> For someone who is interested in how `observe` works can trace the source code of operator.
> - `CharmBase`
>     - Base class that represents the charm overall
> - `CharmEvents`
>     - Events generated by juju pertaining to appplication lifecycle.
>     - This class is used to create an event descriptor (``self.on``) attribute for a charm class that inherits from `CharmBase`. The event descriptor may be used to set up event handlers for corresponding events.
> - `Framework`
>     - Main interface to from the Charm to the Operator Framework internals.


### Defer event on Operator

> See [defer](https://juju.is/docs/sdk/deferring-events-details-and-dilemmas) for more details

```python
def _on_config_changed(self, event):
    if not self._container.can_connect() or not self._liveness_check():
        event.defer()
        return
    self._set_api_key(config['api_key'])
```
